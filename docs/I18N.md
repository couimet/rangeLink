# Internationalization (i18n) Specification

This document defines RangeLink's internationalization architecture and implementation plan.

## Overview

RangeLink's i18n system enables localized informational messages while keeping error handling language-independent. The system uses `RangeLinkMessageCode` as stable identifiers mapped to localized templates.

## Architecture

### RangeLinkMessageCode (i18n System)

**Purpose:** Stable identifiers for informational messages that get localized.

**Scope:**

- Contains ONLY `MSG_xxxx` codes
- Used for user-facing informational messages
- Stable identifiers that never change across languages
- Maps to localized templates in message files

**Examples:**

- `MSG_CONFIG_LOADED` → "Configuration loaded: line={delimiterLine}, column={delimiterPosition}"
- `MSG_CONFIG_USING_DEFAULTS` → "Using default delimiter configuration"
- `MSG_BYOD_PARSED` → "Portable link parsed successfully"

**Note:** ✅ Phase 4.5J Complete (2025-11-05): `RangeLinkMessageCode` now uses descriptive values matching keys exactly (e.g., `CONFIG_LOADED = 'CONFIG_LOADED'`). See [ROADMAP.md Phase 4.5J](./ROADMAP.md#45j-convert-rangelinkmessagecode-to-descriptive-values--complete).

**Coverage Insight:** When i18n is implemented, `RangeLinkMessageCode` will achieve natural test coverage as each locale's translation map must be `Record<RangeLinkMessageCode, string>`, ensuring all enum keys are tested. TypeScript will enforce completeness, and missing keys will cause compilation errors. We'll then be able to remove the `src/types/RangeLinkMessageCode.ts` exception in `jest.config.js` file.

### Key Principle

**User-facing messages get localized** - When displaying status updates or informational messages to users, the system retrieves the appropriate translation based on the user's IDE language setting.

## Message Templates

### Template Syntax

Use `{paramName}` for dynamic values in message templates:

```typescript
// Template
"Configuration loaded: line={delimiterLine}, column={delimiterPosition}"

// Parameters
{ delimiterLine: "L", delimiterPosition: "C" }

// Output
"Configuration loaded: line=L, column=C"
```

### Message Map Structure

```typescript
// src/i18n/messages.en.ts
import { RangeLinkMessageCode } from '../types/RangeLinkMessageCode';

export const messagesEn: Record<RangeLinkMessageCode, string> = {
  [RangeLinkMessageCode.MSG_CONFIG_LOADED]:
    'Configuration loaded: line={delimiterLine}, column={delimiterPosition}, hash={delimiterHash}, range={delimiterRange}',

  [RangeLinkMessageCode.MSG_CONFIG_USING_DEFAULTS]: 'Using default delimiter configuration',

  [RangeLinkMessageCode.MSG_BYOD_PARSED]: 'Portable link parsed successfully',

  // ... more messages
};
```

### Type Safety

Ensure all message codes have translations at compile time:

```typescript
// Type ensures complete coverage
type MessageMap = Record<RangeLinkMessageCode, string>;

// Compiler error if any codes are missing
const messagesEn: MessageMap = {
  // ... must include ALL RangeLinkMessageCode values
};
```

## getMessage Function

### Core Implementation

````typescript
// src/i18n/getMessage.ts
import { RangeLinkMessageCode } from '../types/RangeLinkMessageCode';
import { messagesEn } from './messages.en';

/**
 * Get localized message for a message code with optional parameter substitution.
 *
 * @param code - The message code
 * @param params - Optional parameters for template substitution
 * @param locale - Optional locale override (defaults to configured locale)
 * @returns Localized message with parameters substituted
 *
 * @example
 * ```typescript
 * getMessage(RangeLinkMessageCode.MSG_CONFIG_LOADED, {
 *   delimiterLine: 'L',
 *   delimiterPosition: 'C',
 *   delimiterHash: '#',
 *   delimiterRange: '-'
 * });
 * // Returns: "Configuration loaded: line=L, column=C, hash=#, range=-"
 * ```
 */
export function getMessage(
  code: RangeLinkMessageCode,
  params?: Record<string, string | number>,
  locale?: string,
): string {
  // Get message map for locale (default: 'en')
  const messages = getMessagesForLocale(locale || getCurrentLocale());

  // Get template
  const template = messages[code];
  if (!template) {
    return `[Missing translation: ${code}]`;
  }

  // Substitute parameters if provided
  if (!params) {
    return template;
  }

  return template.replace(/\{(\w+)\}/g, (match, key) => {
    const value = params[key];
    return value !== undefined ? String(value) : match;
  });
}

/**
 * Get message map for a specific locale.
 * Falls back to English if locale not found.
 */
function getMessagesForLocale(locale: string): Record<RangeLinkMessageCode, string> {
  switch (locale) {
    case 'en':
      return messagesEn;
    // Future: case 'fr': return messagesFr;
    // Future: case 'es': return messagesEs;
    default:
      return messagesEn; // Fallback to English
  }
}

/**
 * Get current locale from extension context.
 * Defaults to 'en' if not configured.
 */
function getCurrentLocale(): string {
  return LocaleManager.getCurrentLocale() || 'en';
}
````

### Template Formatting Helper

```typescript
/**
 * Format message template with parameters.
 * Handles missing parameters gracefully.
 *
 * @param template - Message template with {param} placeholders
 * @param params - Parameter values
 * @returns Formatted message
 */
function formatTemplate(template: string, params: Record<string, string | number>): string {
  return template.replace(/\{(\w+)\}/g, (match, key) => {
    const value = params[key];
    if (value === undefined) {
      // Keep placeholder if parameter missing
      return match;
    }
    return String(value);
  });
}
```

## Locale Management

### LocaleManager (Core Layer)

```typescript
// src/i18n/LocaleManager.ts

/**
 * Manages locale configuration for i18n.
 * Locale is injected from extension layer (similar to LogManager pattern).
 */
export class LocaleManager {
  private static currentLocale: string = 'en';

  /**
   * Set current locale.
   * Called by extension layer during initialization.
   */
  static setLocale(locale: string): void {
    this.currentLocale = locale;
  }

  /**
   * Get current locale.
   */
  static getCurrentLocale(): string {
    return this.currentLocale;
  }
}
```

### Extension Layer Integration

```typescript
// packages/rangelink-vscode-extension/src/extension.ts

export function activate(context: vscode.ExtensionContext): void {
  // Get IDE locale
  const locale = vscode.env.language; // e.g., 'en', 'fr', 'es'

  // Inject locale into core layer
  LocaleManager.setLocale(locale);

  // ... rest of activation
}
```

**Benefits:**

- Core remains platform-agnostic
- Extension provides runtime context
- Similar pattern to existing LogManager
- Easy to test with different locales

## Usage Patterns

### Logging Informational Messages

```typescript
import { getMessage } from './i18n/getMessage';
import { RangeLinkMessageCode } from './types/RangeLinkMessageCode';

// Log configuration loaded
logger.info(
  getMessage(RangeLinkMessageCode.MSG_CONFIG_LOADED, {
    delimiterLine: config.delimiterLine,
    delimiterPosition: config.delimiterPosition,
    delimiterHash: config.delimiterHash,
    delimiterRange: config.delimiterRange,
  }),
);

// Log using defaults (no parameters)
logger.info(getMessage(RangeLinkMessageCode.MSG_CONFIG_USING_DEFAULTS));
```

### Error Messages (Not Localized)

```typescript
// Errors remain in English
throw new RangeLinkError({
  code: RangeLinkErrorCodes.SELECTION_EMPTY,
  message: 'Selections array must not be empty',
  functionName: 'validateInputSelection',
  details: { selectionsLength: 0 },
});

// Errors can be logged, but message stays English
logger.error(`Validation failed: ${error.message}`);
```

### Future: User-Facing Notifications

```typescript
// When showing messages to users in VSCode
const message = getMessage(RangeLinkMessageCode.MSG_LINK_COPIED, { linkType: 'portable' });

vscode.window.showInformationMessage(message);
```

## Implementation Status

### Extension-Layer i18n (Complete) — [#104](https://github.com/couimet/rangeLink/issues/104)

✅ **Implemented:** Extension-layer i18n system operational (English only)

**Implementation:**

- `formatMessage()` function with parameter substitution
- `LocaleManager` with locale injection from VSCode
- `MessageCode` enum for extension UI messages
- 10 message codes migrated (status bar, user instructions, config)

**Location:** `packages/rangelink-vscode-extension/src/i18n/`

**Architecture:** Extension-layer only (Option D) - core library stays English for technical messages

### Future Work (See [#37](https://github.com/couimet/rangeLink/issues/37))

- Additional locales (French, Spanish)
- Remaining extension messages (PasteDestinationManager, etc.)
- Translation contribution guidelines

## Testing Strategy

### Unit Tests

```typescript
describe('getMessage', () => {
  it('returns message without parameters', () => {
    const message = getMessage(RangeLinkMessageCode.MSG_CONFIG_USING_DEFAULTS);
    expect(message).toBe('Using default delimiter configuration');
  });

  it('substitutes parameters in template', () => {
    const message = getMessage(RangeLinkMessageCode.MSG_CONFIG_LOADED, {
      delimiterLine: 'L',
      delimiterPosition: 'C',
      delimiterHash: '#',
      delimiterRange: '-',
    });
    expect(message).toBe('Configuration loaded: line=L, column=C, hash=#, range=-');
  });

  it('preserves placeholders for missing parameters', () => {
    const message = getMessage(RangeLinkMessageCode.MSG_CONFIG_LOADED, {
      delimiterLine: 'L',
      // Missing other parameters
    });
    expect(message).toContain('line=L');
    expect(message).toContain('{delimiterPosition}');
  });

  it('falls back to English for unknown locale', () => {
    const message = getMessage(RangeLinkMessageCode.MSG_CONFIG_LOADED, {}, 'unknown');
    expect(message).toBe(messagesEn[RangeLinkMessageCode.MSG_CONFIG_LOADED]);
  });

  it('returns error message for missing translation', () => {
    const invalidCode = 'INVALID_CODE' as RangeLinkMessageCode;
    const message = getMessage(invalidCode);
    expect(message).toBe('[Missing translation: INVALID_CODE]');
  });
});
```

### Integration Tests

```typescript
describe('i18n integration', () => {
  it('uses locale from LocaleManager', () => {
    LocaleManager.setLocale('en');
    const message = getMessage(RangeLinkMessageCode.MSG_CONFIG_LOADED);
    expect(message).toContain('Configuration loaded');
  });

  it('extension layer can override locale', () => {
    LocaleManager.setLocale('fr'); // Future: French messages
    const message = getMessage(RangeLinkMessageCode.MSG_CONFIG_LOADED);
    // Future: expect(message).toContain('Configuration chargée');
  });
});
```

## Migration Path

### Current State

```typescript
// Direct English messages
logger.info('Configuration loaded: line="L", column="C"');
```

### After i18n Implementation

```typescript
// Localized via getMessage
logger.info(
  getMessage(RangeLinkMessageCode.MSG_CONFIG_LOADED, {
    delimiterLine: 'L',
    delimiterPosition: 'C',
    delimiterHash: '#',
    delimiterRange: '-',
  }),
);
```

## Benefits

1. **User Experience**: Users see messages in their IDE language
2. **Maintainability**: All translations in one place per language
3. **Type Safety**: Compiler ensures all codes have translations
4. **Testability**: Easy to test with different locales
5. **Extensibility**: Simple to add new languages
6. **Consistency**: Error messages stay technical (English), user messages get localized

## Related Documentation

- [ERROR-HANDLING.md](./ERROR-HANDLING.md) - Error handling architecture
- [LOGGING.md](./LOGGING.md) - Structured logging approach
- [ARCHITECTURE.md](./ARCHITECTURE.md) - Core library design
